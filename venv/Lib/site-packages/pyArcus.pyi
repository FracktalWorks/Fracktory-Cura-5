# The PEP 484 type hints stub file for the pyArcus module.
#
# Generated by SIP 6.7.11
#
# 


import enum


class ErrorCode(enum.Enum):
    UnknownError = ... # type: ErrorCode
    CreationError = ... # type: ErrorCode
    ConnectFailedError = ... # type: ErrorCode
    BindFailedError = ... # type: ErrorCode
    AcceptFailedError = ... # type: ErrorCode
    SendFailedError = ... # type: ErrorCode
    ReceiveFailedError = ... # type: ErrorCode
    UnknownMessageTypeError = ... # type: ErrorCode
    ParseFailedError = ... # type: ErrorCode
    ConnectionResetError = ... # type: ErrorCode
    MessageRegistrationFailedError = ... # type: ErrorCode
    InvalidStateError = ... # type: ErrorCode
    InvalidMessageError = ... # type: ErrorCode
    Debug = ... # type: ErrorCode


class SocketState(enum.Enum):
    Initial = ... # type: SocketState
    Connecting = ... # type: SocketState
    Connected = ... # type: SocketState
    Opening = ... # type: SocketState
    Listening = ... # type: SocketState
    Closing = ... # type: SocketState
    Closed = ... # type: SocketState
    Error = ... # type: SocketState


class SocketListener(wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, a0: 'SocketListener') -> None: ...

    def error(self, error: 'Error') -> None: ...
    def messageReceived(self) -> None: ...
    def stateChanged(self, newState: SocketState) -> None: ...
    def getSocket(self) -> typing.Optional['Socket']: ...


class PythonMessage(wrapper):

    def __init__(self, a0: 'PythonMessage') -> None: ...

    def getEnumValue(self, enum_value: typing.Any) -> int: ...
    def getMessage(self, field_name: typing.Any) -> typing.Optional['PythonMessage']: ...
    def getRepeatedMessage(self, field_name: typing.Any, index: int) -> typing.Optional['PythonMessage']: ...
    def repeatedMessageCount(self, field_name: typing.Any) -> int: ...
    def addRepeatedMessage(self, field_name: typing.Any) -> typing.Optional['PythonMessage']: ...
    @typing.overload
    def __setattr__(self, a0: typing.Any, a1: typing.Any) -> None: ...
    @typing.overload
    def __setattr__(self, a0: typing.Any) -> None: ...
    def __getattr__(self, a0: typing.Any) -> typing.Optional[typing.Any]: ...
    def __hasattr__(self, a0: typing.Any) -> typing.Optional[bool]: ...
    def getTypeName(self) -> typing.Any: ...


class Error(wrapper):

    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, error_code: ErrorCode, error_message: typing.Any) -> None: ...
    @typing.overload
    def __init__(self, error: 'Error') -> None: ...

    def __repr__(self) -> typing.Any: ...
    def setFatalError(self, fatal: bool) -> None: ...
    def isValid(self) -> bool: ...
    def isFatalError(self) -> bool: ...
    def getErrorMessage(self) -> typing.Any: ...
    def getErrorCode(self) -> ErrorCode: ...


class Socket(wrapper):

    def __init__(self) -> None: ...

    def dumpMessageTypes(self) -> None: ...
    def registerAllMessageTypes(self, file_name: typing.Any) -> bool: ...
    def createMessage(self, type_name: typing.Any) -> typing.Any: ...
    def takeNextMessage(self) -> typing.Any: ...
    def sendMessage(self, message: typing.Any) -> None: ...
    def reset(self) -> None: ...
    def close(self) -> None: ...
    def listen(self, address: typing.Any, port: int) -> None: ...
    def connect(self, address: typing.Any, port: int) -> None: ...
    def removeListener(self, listener: typing.Optional[SocketListener]) -> None: ...
    def addListener(self, listener: typing.Optional[SocketListener]) -> None: ...
    def clearError(self) -> None: ...
    def getLastError(self) -> Error: ...
    def getState(self) -> SocketState: ...
